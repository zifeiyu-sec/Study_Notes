在面向对象编程（OOP）中，类、抽象类、接口、继承、多态是核心概念，它们共同构建了代码的结构和交互方式

### **1. 类（Class）**

**定义**：类是对象的模板，封装了数据（属性）和操作数据的方法（行为），用于创建具体实例（对象）。

**特点**：

- 可以包含具体实现的方法（有方法体）。

- 可以被继承，也可以直接实例化（创建对象）。

**示例（Java）**：

```
// 定义一个"动物"类
class Animal {
    // 属性（数据）
    String name;
    
    // 构造方法（初始化对象）
    public Animal(String name) {
        this.name = name;
    }
    
    // 具体方法（有实现）
    public void eat() {
        System.out.println(name + "在吃东西");
    }
}

// 实例化类（创建对象）
public class Main {
    public static void main(String[] args) {
        Animal dog = new Animal("小狗");
        dog.eat(); // 输出：小狗在吃东西
    }
}
```

### **2. 抽象类（Abstract Class）**

**定义**：==***被 abstract 修饰的类，用于定义通用模板，不能直接实例化，必须被继承。***==

**特点**：

- 可以包含 **抽象方法**（无方法体，用 abstract 修饰）和 **具体方法**（有实现）。

- 子类必须实现抽象类中所有的抽象方法（除非子类也是抽象类）。

- 目的是为子类提供统一的接口，同时保留部分通用实现。

**示例**：

```
// 抽象类（动物）
abstract class Animal {
    String name;
    
    public Animal(String name) {
        this.name = name;
    }
    
    // 具体方法（通用实现）
    public void breathe() {
        System.out.println(name + "在呼吸");
    }
    
    // 抽象方法（子类必须实现）
    public abstract void makeSound();
}

// 继承抽象类（必须实现抽象方法）
class Dog extends Animal {
    public Dog(String name) {
        super(name); // 调用父类构造方法
    }
    
    // 实现抽象方法
    @Override
    public void makeSound() {
        System.out.println(name + "汪汪叫");
    }
}

// 使用
public class Main {
    public static void main(String[] args) {
        Animal dog = new Dog("小狗");
        dog.breathe(); // 输出：小狗在呼吸（继承自抽象类的具体方法）
        dog.makeSound(); // 输出：小狗汪汪叫（子类实现的抽象方法）
    }
}
```

### **3. 接口（Interface）**

**定义**：接口是一种特殊的 "契约"，仅定义方法签名（无实现），用于规范类的行为。

**特点**：

- 所有方法默认是 public abstract（无需显式声明）。

- 不能包含构造方法，不能实例化。

- 类通过 implements 关键字实现接口，必须实现接口中所有方法。

- 一个类可以实现多个接口（弥补单继承限制）。

**示例**：

```
// 定义"会飞"接口
interface Flyable {
    void fly(); // 抽象方法，无实现
}

// 定义"会游泳"接口
interface Swimmable {
    void swim();
}

// 类实现多个接口（必须实现所有方法）
class Duck implements Flyable, Swimmable {
    @Override
    public void fly() {
        System.out.println("鸭子在飞");
    }
    
    @Override
    public void swim() {
        System.out.println("鸭子在游");
    }
}

// 使用
public class Main {
    public static void main(String[] args) {
        Duck duck = new Duck();
        duck.fly(); // 输出：鸭子在飞
        duck.swim(); // 输出：鸭子在游
    }
}
```

> 在 Java 中，接口的定义和接口中的成员（方法、常量）有明确的默认修饰规则：
>
> ### 1. 接口本身的默认修饰符
>
> 接口声明时，若未显式指定访问修饰符，则默认是 **包私有（package-private）**，即仅允许同一包内的类访问。
>
> 但接口通常会显式声明为 public，以允许跨包访问，例如：
>
> ```
> // 未显式声明public，默认包私有
> interface MyInterface { ... }
> 
> // 显式声明public（推荐，便于跨包使用）
> public interface PublicInterface { ... }
> ```
>
> 注意：接口不能被声明为 private 或 protected，这两种修饰符仅适用于类的成员。
>
> ### 2. 接口中方法的默认修饰符
>
> - **Java 8 及之前**：接口中的所有方法默认被 public abstract 修饰（即使不写也会隐式添加）。
>
> 例如：
>
> ```
> interface Flyable {
>     void fly(); // 等价于 public abstract void fly();
> }
> ```
>
> - **Java 8 及之后**：新增了 **默认方法（default）** 和 **静态方法（static）**，这两种方法必须显式声明修饰符，且默认方法有方法体：
>
> ```
> interface Flyable {
>     // 抽象方法（默认 public abstract）
>     void fly();
>     
>     // 默认方法（必须显式写 default，且有方法体）
>     default void land() {
>         System.out.println("降落");
>     }
>     
>     // 静态方法（必须显式写 static）
>     static void prepare() {
>         System.out.println("准备飞行");
>     }
> }
> ```
>
> ### 3. 接口中常量的默认修饰符
>
> 接口中定义的变量默认被 public static final 修饰（即常量），必须在声明时初始化，且无法被修改：
>
> ```
> interface Constants {
>     int MAX_SPEED = 100; // 等价于 public static final int MAX_SPEED = 100;
> }
> ```
>
> ### 总结
>
> - 接口本身默认是 **包私有**，但通常显式声明为 public。
>
> - 接口中的抽象方法默认是 public abstract（Java 8+ 中新增的 default/static 方法除外）。
>
> - 接口中的变量默认是 public static final（常量）。
>
> 这些默认修饰符是 Java 语法的规定，目的是保证接口作为 "行为契约" 的纯粹性和规范性。

### **4. 继承（Inheritance）**

**定义**：子类（Subclass）通过 extends 关键字继承父类（Superclass）的属性和方法，实现代码复用。

**特点**：

- 单继承：Java 中一个类只能直接继承一个父类（但可多层继承，如 A→B→C）。

- 子类可重写（@Override）父类的方法，修改或扩展行为。

- 父类的私有（private）成员无法被继承。

**示例**：

```
// 父类
class Animal {
    public void eat() {
        System.out.println("动物吃东西");
    }
}

// 子类继承父类
class Cat extends Animal {
    // 重写父类方法
    @Override
    public void eat() {
        System.out.println("猫吃猫粮");
    }
    
    // 子类新增方法
    public void catchMouse() {
        System.out.println("猫抓老鼠");
    }
}

// 使用
public class Main {
    public static void main(String[] args) {
        Cat cat = new Cat();
        cat.eat(); // 输出：猫吃猫粮（重写后的方法）
        cat.catchMouse(); // 输出：猫抓老鼠（子类特有方法）
    }
}
```

### **5. 多态（Polymorphism）**

**定义**：同一行为（方法）在不同对象上有不同表现形式。

**实现条件**：

1. 继承（或实现接口）。

1. 子类重写父类方法。

1. 父类引用指向子类对象（父类 变量 = new 子类()）。

**示例**：

```
// 父类
class Animal {
    public void makeSound() {
        System.out.println("动物叫");
    }
}

// 子类1
class Dog extends Animal {
    @Override
    public void makeSound() {
        System.out.println("汪汪叫");
    }
}

// 子类2
class Cat extends Animal {
    @Override
    public void makeSound() {
        System.out.println("喵喵叫");
    }
}

// 多态体现：同一方法调用，不同对象有不同结果
public class Main {
    public static void main(String[] args) {
        Animal animal1 = new Dog(); // 父类引用指向Dog对象
        Animal animal2 = new Cat(); // 父类引用指向Cat对象
        
        animal1.makeSound(); // 输出：汪汪叫
        animal2.makeSound(); // 输出：喵喵叫
    }
}
```

### **6. 抽象类的继承**

抽象类的继承与普通类类似，但子类必须实现抽象类中所有的抽象方法（除非子类也是抽象类）。

**示例**：

```
// 抽象父类
abstract class Shape {
    public abstract double getArea(); // 抽象方法：计算面积
}

// 子类继承并实现抽象方法
class Circle extends Shape {
    private double radius;
    
    public Circle(double radius) {
        this.radius = radius;
    }
    
    @Override
    public double getArea() {
        return Math.PI * radius * radius; // 圆的面积公式
    }
}

// 使用
public class Main {
    public static void main(String[] args) {
        Shape circle = new Circle(2.0);
        System.out.println("圆的面积：" + circle.getArea()); // 输出：~12.566
    }
}
```

### **7. 接口的实现**

类通过 implements 关键字实现接口，必须实现接口中所有方法。一个类可以实现多个接口，解决单继承的局限性。

**示例**：

```
// 接口1
interface Runable {
    void run();
}

// 接口2
interface Jumpable {
    void jump();
}

// 类实现多个接口
class Rabbit implements Runable, Jumpable {
    @Override
    public void run() {
        System.out.println("兔子跑");
    }
    
    @Override
    public void jump() {
        System.out.println("兔子跳");
    }
}

// 使用
public class Main {
    public static void main(String[] args) {
        Rabbit rabbit = new Rabbit();
        rabbit.run(); // 输出：兔子跑
        rabbit.jump(); // 输出：兔子跳
    }
}
```

### **总结**

| 概念   | 核心作用                          | 方法特点                           | 实例化 | 继承 / 实现规则            |
| ------ | --------------------------------- | ---------------------------------- | ------ | -------------------------- |
| 类     | 封装属性和方法，创建对象          | 可包含具体方法                     | 可以   | 单继承                     |
| 抽象类 | 定义通用模板，部分实现 + 部分抽象 | 含抽象方法（必须被实现）和具体方法 | 不可以 | 单继承，子类需实现抽象方法 |
| 接口   | 定义行为规范，纯抽象              | 只有抽象方法（无实现）             | 不可以 | 多实现，类需实现所有方法   |
| 继承   | 代码复用，扩展父类功能            | 子类可重写父类方法                 | -      | 单继承                     |
| 多态   | 同一方法在不同对象上有不同表现    | 基于继承和方法重写                 | -      | 父类引用指向子类对象       |

这些概念的核心目的是 **提高代码复用性、扩展性和可维护性**，是设计灵活且健壮的面向对象程序的基础。